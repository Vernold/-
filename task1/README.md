##Баранчук Дмитрий Александрович

##Группа: 321

###OS: MacOS X
###CPU: 2,8 GHz Intel Core i5

###1. Исходная программа

Тесты: 5 замеров, min = 10.80, max = 12.47


###2. Поменял порядок обхода массива

Тесты: 5 замеров, min = 1.181, max = 1.217


Чтобы узнать причину, почему порядок прохода массива настолько сильно влияет на скорость, я протестировал программу на SIZE = 1000, 100 и 10, и зафиксировал, что разница во времени разных обходов уменьшается и к SIZE=10 вовсе исчезает. При size = 10000 один массив будет занимать ~2.2Gb. Следовательно, можно сделать вывод, что проблема заключается в управлении памяти, а именно в использовании кэша. При обратном проходе мы обращаемся к данным, которых нет в кэше и вынуждены каждый раз обращаться к ОЗУ и перезаписывать его. При последовательном обходе мы обрабатываем значения, которые находятся в кэше и значительно уменьшаем число обращений к ОЗУ.


###3. Поменял постфиксную операцию инкремента на префиксную
Тесты: 5 замеров, min = 1.179, max = 1.219


Результат не изменился, так как вступает в дело компилятор, который обоим видам операции сопоставляет один и тот же ассемблерный код.


###4. Используем оптимизирующую опцию компилятора -O2
Тесты: 5 замеров, min = 0.953, max = 0.987


Улучшение производительности обусловлено тем, что компилятор, начиная с этого уровня, использует векторизацию циклов и также ряд базовых оптимизаций с циклами.
